# Developer: Shubh Savani
# Designer of Backtracking Algorithm Implementation: Dante Sblendorio
import time
import numpy as np
import pandas as pd
import argparse


def shape_puzzles(collection):
    for ind in range(collection.shape[0]):
        collection.iloc[ind, 0] = np.reshape(list(collection.puzzle.values[ind]), (9, 9)).astype(int)
        collection.iloc[ind, 1] = np.reshape(list(collection.solution.values[ind]), (9, 9)).astype(int)
    return collection


def checkPuzzle(sudoku_puzzle):
    checkRow = all([all([x in sudoku_puzzle[nrow, :] for x in range(1, 10)]) for nrow in range(9)])
    checkCol = all([all([x in sudoku_puzzle[:, ncol] for x in range(1, 10)]) for ncol in range(9)])

    checkUpperLeft = all([x in sudoku_puzzle[0:3, 0:3] for x in range(1, 10)])
    checkUpperMid = all([x in sudoku_puzzle[0:3, 3:6] for x in range(1, 10)])
    checkUpperRight = all([x in sudoku_puzzle[0:3, 6:9] for x in range(1, 10)])

    checkMidLeft = all([x in sudoku_puzzle[3:6, 0:3] for x in range(1, 10)])
    checkMidMid = all([x in sudoku_puzzle[3:6, 3:6] for x in range(1, 10)])
    checkMidRight = all([x in sudoku_puzzle[3:6, 6:9] for x in range(1, 10)])

    checkLowerLeft = all([x in sudoku_puzzle[6:9, 0:3] for x in range(1, 10)])
    checkLowerMid = all([x in sudoku_puzzle[6:9, 3:6] for x in range(1, 10)])
    checkLowerRight = all([x in sudoku_puzzle[6:9, 6:9] for x in range(1, 10)])

    solved = all([checkRow, checkCol, checkUpperLeft, checkUpperMid, checkUpperRight,
                  checkMidLeft, checkMidMid, checkMidRight, checkLowerLeft, checkLowerMid, checkLowerRight])
    if solved:
        for line in sudoku_puzzle:
            print(*line)
    return solved


def determineValues(sudoku_puzzle):
    puzzle_values = list()
    for r in range(9):
        for c in range(9):
            if sudoku_puzzle[r, c] == 0:
                cell_values = np.array(range(1, 10))
                cell_values = np.setdiff1d(cell_values,
                                           sudoku_puzzle[r, :][np.where(sudoku_puzzle[r, :] != 0)]).tolist()
                cell_values = np.setdiff1d(cell_values,
                                           sudoku_puzzle[:, c][np.where(sudoku_puzzle[:, c] != 0)]).tolist()
            else:
                cell_values = [sudoku_puzzle[r, c]]
            puzzle_values.append(cell_values)
    return puzzle_values


def checkGrids(r, c, sudoku_puzzle, n):
    if r < 3:
        if c < 3:
            subgrid = n in sudoku_puzzle[0:3, 0:3]
        elif c < 6:
            subgrid = n in sudoku_puzzle[0:3, 3:6]
        else:
            subgrid = n in sudoku_puzzle[0:3, 6:9]
    elif r < 6:
        if c < 3:
            subgrid = n in sudoku_puzzle[3:6, 0:3]
        elif c < 6:
            subgrid = n in sudoku_puzzle[3:6, 3:6]
        else:
            subgrid = n in sudoku_puzzle[3:6, 6:9]
    else:
        if c < 3:
            subgrid = n in sudoku_puzzle[6:9, 0:3]
        elif c < 6:
            subgrid = n in sudoku_puzzle[6:9, 3:6]
        else:
            subgrid = n in sudoku_puzzle[6:9, 6:9]
    return subgrid


def solve(sudoku_puzzle, puzzle_values):
    count = 0
    solution = False
    rows = np.array(np.where(sudoku_puzzle == 0))[0]
    cols = np.array(np.where(sudoku_puzzle == 0))[1]
    dic = dict(zip(list(range(len(rows))), np.zeros(len(rows), dtype=int).tolist()))
    while not solution:
        if count >= len(rows):
            solution = checkPuzzle(sudoku_puzzle)
            break
        r = rows[count]
        c = cols[count]
        len_num = len(np.array(puzzle_values).reshape(9, 9)[r, c])
        num = dic[count]
        while num < len_num:
            cell = np.array(puzzle_values).reshape(9, 9)[r, c][num]
            checkRow = cell in sudoku_puzzle[r, :]
            if checkRow:
                num += 1
                continue
            checkCol = cell in sudoku_puzzle[:, c]
            if checkCol:
                num += 1
                continue
            checkGrid = checkGrids(r, c, sudoku_puzzle, cell)
            if checkGrid:
                num += 1
                continue
            dic[count] = num
            count += 1
            sudoku_puzzle[r, c] = cell
            break
        else:
            sudoku_puzzle[r, c] = 0
            dic[count] = 0
            count -= 1


def file_reader(file_name):
    puzzle = []
    file = open(file_name)
    valid_inputs = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
    for ind in range(9):
        line = file.readline()
        row = line.split()
        puzzle.append(row)
    #  convert each value in puzzle from a string to an integer
    for row in range(len(puzzle)):
        for col in range(len(puzzle[row])):
            val_str = puzzle[row][col]
            if val_str not in valid_inputs:
                raise ValueError("Input must be an integer from 0 to 9")
            puzzle[row][col] = int(val_str)
    input_array = np.array([puzzle[0], puzzle[1], puzzle[2], puzzle[3], puzzle[4], puzzle[5], puzzle[6], puzzle[7], puzzle[8]])
    return input_array


def main():
    # Get the input file from the cmd command
    parser = argparse.ArgumentParser(description='Solve Sudoku Puzzle with Backtracking Algorithm '
                                                 'with MRV/degree heuristics and RGB order')
    parser.add_argument('filename', help='The input file containing the initial and goal state')
    cmdline = parser.parse_args()
    file_name = cmdline.filename

    # Parses the file and creates a 2D array that stores each cell as an int value and handles error inputs
    # sudoku_puzzle = np.array([[8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 6, 0, 0, 0, 0, 0], [0, 7, 0, 0, 9, 0, 2, 0, 0],
    #                           [0, 5, 0, 0, 0, 7, 0, 0, 0], [0, 0, 0, 0, 4, 5, 7, 0, 0], [0, 0, 0, 1, 0, 0, 0, 3, 0],
    #                           [0, 0, 1, 0, 0, 0, 0, 6, 8], [0, 0, 8, 5, 0, 0, 0, 1, 0], [0, 9, 0, 0, 0, 0, 4, 0, 0]])
    # sudoku_puzzle_2 = np.array([[7, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 3, 0, 0], [0, 3, 0, 5, 2, 1, 0, 0, 9],
    #                           [0, 0, 8, 1, 0, 5, 0, 3, 0], [4, 0, 0, 0, 9, 0, 0, 0, 7], [0, 1, 0, 3, 0, 4, 5, 0, 0],
    #                           [6, 0, 0, 7, 3, 8, 0, 1, 0], [0, 0, 1, 0, 0, 0, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 3]])
    sudoku_puzzle = file_reader(file_name)
    # sudoku_df = pd.DataFrame(pd.read_csv('sudoku.csv', nrows=100))  # imports first 100 puzzles and solutions
    # # for training/testing
    # shaped_puzzles = shape_puzzles(sudoku_df)
    start = time.perf_counter()
    puzzle_vals = determineValues(sudoku_puzzle)
    print(solve(sudoku_puzzle, puzzle_vals))
    end = time.perf_counter()
    total_time  = end - start
    print("Runtime: ", total_time)
    # print(puzzle_vals)
    # print(shaped_puzzles.iloc[0, 0])
    # print(shaped_puzzles.iloc[0, 1])


if __name__ == '__main__':
    main()
